@0x8d5f75cd80edffd6; # unique file ID, generated by `capnp id`

using Common = import "../common.capnp";
using Json = Common.Json;

$import "/capnp/c++.capnp".namespace("koinos::protocol");

using Go = import "/go.capnp";
$Go.package("protocol");
$Go.import("github.com/koinos/koinos-proto-golang/koinos/protocol");

struct UploadContractOperation {
   contractID @0 :Common.Hash $Json.hex;
   bytecode   @1 :Data;
}

struct CallContractOperation {
   contractID @0 :Common.Hash $Json.hex;
   entryPoint @1 :UInt32;
   args       @2 :Data;
}

struct SetSystemCallOperation {
   callID @0 :UInt32;
   target @1 :Common.SystemCallTarget;
}

struct Operation {
   op :union $Json.discriminator() {
      nop            @0 :Void;
      uploadContract @1 :UploadContractOperation;
      callContract   @2 :CallContractOperation;
      setSystemCall  @3 :SetSystemCallOperation;
   }
}

struct ActiveTransactionData {
   resourceLimit @0 :Void; # Needs to be UInt128
   nonce         @1 :UInt64;
   operations    @2 :List(Operation);
}

struct PassiveTransactionData {
}

struct Transaction {
   id @0 :Common.Hash $Json.hex;

   activeData: union {
      native @1 :ActiveTransactionData;
      bytes  @2 :Data;
   }

   passiveData: union {
      native @3 :PassiveTransactionData;
      bytes  @4 :Data;
   }

   signatureData @5 :Data;
}


struct ActiveBlockData {
   transactionMerkleRoot @0 :Common.Hash $Json.hex;
   passiveDataMerkleRoot @1 :Common.Hash $Json.hex;
   signer                @2 :Data;
}

struct PassiveBlockData {
}

struct BlockHeader {
   previous  @0 :Common.Hash $Json.hex;
   height    @1 :Common.BlockHeightType;
   timestamp @2 :Common.Timestamp;
}


# Topological constraints:  Constraints for a new block b that builds on a given block a
#
# b.header.previous_block == a.block_id
# b.header.height         == a.header.height+1
# b.header.timestamp      >  a.header.timestamp
#
# Cryptographic constraints:  Internal constraints for block b.
#
# b.block_id                             == H(b.header, b.active_data)
# b.active_data.transaction_merkle_root  == Hm(b.transactions)
# b.active_data.passive_data_merkle_root == Hm(b.passive_data)
# b.active_data.signer_address           == H(recover(b.signature_data, b.block_id))

struct Block {
   id            @0 :Common.Hash $Json.hex;
   header        @1 :BlockHeader;
   activeData    @2 :Common.Opaque(ActiveBlockData);
   passiveData   @3 :Common.Opaque(PassiveBlockData);
   signatureData @4 :Data;
   transactions  @5 :List(Transaction);
}

struct BlockReceipt {
}
