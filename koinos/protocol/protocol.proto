syntax = "proto3";

package koinos.protocol;
option go_package = "github.com/koinos/koinos-proto-golang/koinos/protocol";

import "koinos/options.proto";

message event_data {
   uint32 sequence = 1;
   bytes source = 2 [(koinos_bytes_type) = CONTRACT_ID];
   string name = 3;
   bytes data = 4;
   repeated bytes impacted = 5 [(koinos_bytes_type) = ADDRESS];
}

message contract_call_bundle {
   bytes contract_id = 1 [(koinos_bytes_type) = CONTRACT_ID];
   uint32 entry_point = 2;
}

message system_call_target {
   oneof target {
      uint32 thunk_id = 1;
      contract_call_bundle system_call_bundle = 2;
   }
}

message upload_contract_operation {
   bytes contract_id = 1 [(koinos_bytes_type) = CONTRACT_ID];
   bytes bytecode = 2;
}

message call_contract_operation {
   bytes contract_id = 1 [(koinos_bytes_type) = CONTRACT_ID];
   uint32 entry_point = 2;
   bytes args = 3;
}

message set_system_call_operation {
   uint32 call_id = 1;
   system_call_target target = 2;
}

message operation {
   oneof op {
      upload_contract_operation upload_contract = 1;
      call_contract_operation call_contract = 2;
      set_system_call_operation set_system_call = 3;
   }
}

message active_transaction_data {
   uint64 rc_limit = 1 [jstype = JS_STRING];
   uint64 nonce = 2 [jstype = JS_STRING];
   repeated operation operations = 3;
}

message passive_transaction_data {}

message transaction {
   bytes id = 1 [(koinos_bytes_type) = TRANSACTION_ID];
   bytes active = 2;
   bytes passive = 3;
   bytes signature_data = 4;
}

message transaction_receipt {
   bytes id = 1 [(koinos_bytes_type) = TRANSACTION_ID];
   bytes payer = 2 [(koinos_bytes_type) = ADDRESS];
   uint64 max_payer_rc = 3 [jstype = JS_STRING];
   uint64 rc_limit = 4 [jstype = JS_STRING];
   uint64 rc_used = 5 [jstype = JS_STRING];
   uint64 disk_storage_used = 6 [jstype = JS_STRING];
   uint64 network_bandwidth_used = 7 [jstype = JS_STRING];
   uint64 compute_bandwidth_used = 8 [jstype = JS_STRING];
   bool reverted = 9;
   repeated event_data events = 10;
}

message active_block_data {
   bytes transaction_merkle_root = 1;
   bytes passive_data_merkle_root = 2;
   bytes signer = 3;
}

message passive_block_data {}

message block_header {
   bytes previous = 1 [(koinos_bytes_type) = BLOCK_ID];
   uint64 height = 2 [jstype = JS_STRING];
   uint64 timestamp = 3 [jstype = JS_STRING];
}

// Topological constraints:  Constraints for a new block b that builds on a given block a
//
// b.header.previous_block == a.block_id
// b.header.height         == a.header.height+1
// b.header.timestamp      >  a.header.timestamp
//
// Cryptographic constraints:  Internal constraints for block b.
//
// b.block_id                             == H(b.header, b.active_data)
// b.active_data.transaction_merkle_root  == Hm(b.transactions)
// b.active_data.passive_data_merkle_root == Hm(b.passive_data)
// b.active_data.signer_address           == H(recover(b.signature_data, b.block_id))
message block {
   bytes id = 1 [(koinos_bytes_type) = BLOCK_ID];
   block_header header = 2;
   bytes active = 3;
   bytes passive = 4;
   bytes signature_data = 5;
   repeated transaction transactions = 6;
}

message block_receipt {
   bytes id = 1 [(koinos_bytes_type) = BLOCK_ID];
   uint64 disk_storage_used = 2 [jstype = JS_STRING];
   uint64 network_bandwidth_used = 3 [jstype = JS_STRING];
   uint64 compute_bandwidth_used = 4 [jstype = JS_STRING];
   repeated event_data events = 5;
   repeated transaction_receipt transaction_receipts = 6;
}
